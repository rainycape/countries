// +build IGNORE

package main

import (
	"bufio"
	"bytes"
	"fmt"
	"go/format"
	"io/ioutil"
	"net/http"
	"sort"
	"strings"
)

type Country struct {
	Name, ISO2, ISO3 string
}

type CountriesByName []*Country

func (c CountriesByName) Len() int           { return len(c) }
func (c CountriesByName) Swap(i, j int)      { c[i], c[j] = c[j], c[i] }
func (c CountriesByName) Less(i, j int) bool { return c[i].ISO2 < c[j].ISO2 }

var (
	// These names have been manually added for
	// compatibility reasons.
	addedCountries = []*Country{
		// Countries that don't exist anymore.
		{"East Germany", "DE", "DEU"},
		{"West Germany", "DE", "DEU"},
		{"Yugoslavia", "YU", "YUG"},
		{"Federal Republic of Yugoslavia", "YU", "YUG"},
		{"Soviet Union", "SU", "SUN"},
		{"Czechoslovakia", "CS", "CSK"},
		{"North Vietnam", "VD", "VDR"}, // http://www.statoids.com/w3166his.html - see change in 1977
		{"Korea", "KR", "KOR"},         // Not really a valid one, since Korea might refer to pre-WW2 Korea
		{"Zaire", "ZR", "ZAR"},
		// Aliases
		{"Siam", "TH", "THA"}, // See https://en.wikipedia.org/wiki/Siam_(disambiguation)
		{"Burma", "MM", "MMR"},
		{"Congo", "CG", "COG"},
		{"The Democratic Republic Of Congo", "CD", "COD"},
		{"CÃ´te d'Ivoire", "CI", "CIV"},
		{"Republic of Macedonia", "MK", "MKD"},
		{"Timor-Leste", "TL", "TLS"},
		// Some data not included by Geonames
		{"Palestine", "PS", "PSE"},
		{"Holy See (Vatican City State)", "VA", "VAT"},
	}
)

func main() {
	resp, err := http.Get("http://download.geonames.org/export/dump/countryInfo.txt")
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	s := bufio.NewScanner(resp.Body)
	// Maps for parsing
	iso2Codes := make(map[string]struct{})
	iso2ByName := make(map[string]string)
	iso2ByIso3 := make(map[string]string)
	iso2ByFips := make(map[string]string)

	var countries []*Country
	for s.Scan() {
		line := s.Text()
		if len(line) == 0 || line[0] == '#' {
			continue
		}
		fields := strings.Split(line, "\t")
		iso2 := fields[0]
		iso3 := fields[1]
		fips := fields[3]
		name := strings.TrimSpace(fields[4])
		iso2Codes[iso2] = struct{}{}
		iso2ByName[strings.ToUpper(name)] = iso2
		iso2ByIso3[iso3] = iso2
		iso2ByFips[fips] = iso2

		countries = append(countries, &Country{
			Name: name, ISO2: iso2, ISO3: iso3,
		})
	}
	if err := s.Err(); err != nil {
		panic(err)
	}
	for _, v := range addedCountries {
		_, isAlias := iso2Codes[v.ISO2]
		iso2Codes[v.ISO2] = struct{}{}
		iso2ByName[strings.ToUpper(v.Name)] = v.ISO2
		iso2ByIso3[v.ISO3] = v.ISO2
		// Note that some countries in this list
		// are aliases, so we must not overwrite
		// other entries.
		if !isAlias {
			countries = append(countries, v)
		}
	}
	var buf bytes.Buffer
	buf.WriteString("package countries\n\n")
	buf.WriteString("// autogenerated with go generate - DO NOT EDIT\n\n")
	dumpStructMap(&buf, "iso2Codes", iso2Codes)
	dumpStringMap(&buf, "iso2ByName", iso2ByName)
	dumpStringMap(&buf, "iso2ByIso3", iso2ByIso3)
	dumpStringMap(&buf, "iso2ByFips", iso2ByFips)

	sort.Sort(CountriesByName(countries))

	fmt.Fprint(&buf, "var countriesByIso2 = map[string]Country{\n")
	for _, c := range countries {
		fmt.Fprintf(&buf, "%q: Country{Name: %q, ISO2: %q, ISO3: %q},\n", c.ISO2, c.Name, c.ISO2, c.ISO3)
	}
	fmt.Fprint(&buf, "}\n\n")

	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		panic(err)
	}
	if err := ioutil.WriteFile("countries_gen.go", formatted, 0644); err != nil {
		panic(err)
	}
}

func dumpStructMap(buf *bytes.Buffer, name string, m map[string]struct{}) {
	fmt.Fprintf(buf, "var %s = map[string]struct{}{\n", name)
	var keys []string
	for k := range m {
		keys = append(keys, k)
	}
	sort.Strings(keys)
	for _, k := range keys {
		fmt.Fprintf(buf, "%q: struct{}{},\n", k)
	}
	fmt.Fprint(buf, "}\n\n")
}

func dumpStringMap(buf *bytes.Buffer, name string, m map[string]string) {
	fmt.Fprintf(buf, "var %s = map[string]string{\n", name)
	var keys []string
	for k := range m {
		keys = append(keys, k)
	}
	sort.Strings(keys)
	for _, k := range keys {
		fmt.Fprintf(buf, "%q: %q,\n", k, m[k])
	}
	fmt.Fprint(buf, "}\n\n")
}
